{% extends "base.html" %}

{% block content %}
<div class="complexity-section">
    <h2>Dynamic Programming: Time and Space Complexity Analysis</h2>

    <div class="complexity-overview">
        <p>Dynamic Programming solutions typically trade space for time, achieving better time complexity by storing intermediate results. Understanding the complexity analysis helps in choosing the right approach and optimizing solutions.</p>
    </div>

    <div class="common-problems">
        <h3>Common DP Problems Complexity Analysis</h3>
        <table class="complexity-table">
            <thead>
                <tr>
                    <th>Problem</th>
                    <th>Time Complexity</th>
                    <th>Space Complexity</th>
                    <th>Notes</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>Fibonacci</td>
                    <td>O(n)</td>
                    <td>O(n)</td>
                    <td>Can be optimized to O(1) space</td>
                </tr>
                <tr>
                    <td>0/1 Knapsack</td>
                    <td>O(nW)</td>
                    <td>O(nW)</td>
                    <td>n items, W capacity</td>
                </tr>
                <tr>
                    <td>Longest Common Subsequence</td>
                    <td>O(mn)</td>
                    <td>O(mn)</td>
                    <td>Strings of length m and n</td>
                </tr>
                <tr>
                    <td>Edit Distance</td>
                    <td>O(mn)</td>
                    <td>O(mn)</td>
                    <td>Can be optimized to O(min(m,n)) space</td>
                </tr>
                <tr>
                    <td>Matrix Chain Multiplication</td>
                    <td>O(n³)</td>
                    <td>O(n²)</td>
                    <td>n matrices</td>
                </tr>
                <tr>
                    <td>Longest Increasing Subsequence</td>
                    <td>O(n²)</td>
                    <td>O(n)</td>
                    <td>Can be optimized to O(n log n) time</td>
                </tr>
            </tbody>
        </table>
    </div>

    <div class="implementation-comparison">
        <h3>Top-Down vs Bottom-Up Complexity Comparison</h3>
        
        <div class="comparison-item">
            <h4>Top-Down (Memoization)</h4>
            <ul>
                <li><strong>Time Complexity:</strong> Generally same as bottom-up</li>
                <li><strong>Space Complexity:</strong> Extra space for recursion stack</li>
                <li><strong>Advantages:</strong>
                    <ul>
                        <li>Easier to implement</li>
                        <li>Computes only needed states</li>
                        <li>Natural recursive structure</li>
                    </ul>
                </li>
                <li><strong>Disadvantages:</strong>
                    <ul>
                        <li>Stack overflow for large inputs</li>
                        <li>Function call overhead</li>
                    </ul>
                </li>
            </ul>
        </div>

        <div class="comparison-item">
            <h4>Bottom-Up (Tabulation)</h4>
            <ul>
                <li><strong>Time Complexity:</strong> Generally same as top-down</li>
                <li><strong>Space Complexity:</strong> Often can be optimized</li>
                <li><strong>Advantages:</strong>
                    <ul>
                        <li>Better space complexity</li>
                        <li>No recursion overhead</li>
                        <li>Better cache performance</li>
                    </ul>
                </li>
                <li><strong>Disadvantages:</strong>
                    <ul>
                        <li>May compute unnecessary states</li>
                        <li>Sometimes harder to implement</li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>

    <div class="optimization-techniques">
        <h3>Space Optimization Techniques</h3>
        <ul>
            <li><strong>State Reduction:</strong> Identify and eliminate redundant states</li>
            <li><strong>Rolling Array:</strong> Use modulo to reuse array space</li>
            <li><strong>State Compression:</strong> Use bits to represent states</li>
            <li><strong>Memory Function:</strong> Clear memory for unused states</li>
        </ul>
    </div>

    <div class="complexity-tips">
        <h3>Tips for Complexity Analysis</h3>
        <ol>
            <li>Count the number of unique subproblems</li>
            <li>Analyze the work done per subproblem</li>
            <li>Consider the recursion tree depth</li>
            <li>Look for opportunities to reduce space usage</li>
            <li>Consider the initialization cost</li>
        </ol>
    </div>
</div>

{% block extra_css %}
<style>
.complexity-section {
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
}

.complexity-overview {
    font-size: 1.1em;
    line-height: 1.6;
    margin-bottom: 2em;
}

.complexity-table {
    width: 100%;
    border-collapse: collapse;
    margin: 1em 0;
}

.complexity-table th,
.complexity-table td {
    padding: 0.75em;
    border: 1px solid #ddd;
    text-align: left;
}

.complexity-table th {
    background-color: #f5f5f5;
    font-weight: bold;
}

.complexity-table tr:nth-child(even) {
    background-color: #f9f9f9;
}

.comparison-item {
    background-color: #f8f9fa;
    border-radius: 4px;
    padding: 1em;
    margin: 1em 0;
}

h3 {
    color: #2c3e50;
    border-bottom: 2px solid #eee;
    padding-bottom: 0.5em;
    margin-top: 1.5em;
}

h4 {
    color: #2c3e50;
    margin-top: 0;
    margin-bottom: 0.5em;
}

ul, ol {
    padding-left: 20px;
    margin-top: 0.5em;
}

li {
    margin: 5px 0;
    line-height: 1.5;
}

.optimization-techniques ul,
.complexity-tips ol {
    background-color: #f8f9fa;
    border-radius: 4px;
    padding: 1em 1em 1em 2.5em;
    margin: 1em 0;
}

strong {
    color: #2c3e50;
}
</style>
{% endblock %}
{% endblock %} 